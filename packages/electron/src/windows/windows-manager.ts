import { BrowserWindow, MessageChannelMain, net, session } from 'electron'
import path from 'path'

import { AppProcessIDs, CommandRegistryEvents } from '@angelfish/core'
import { CommandsRegistryMain } from '../commands/commands-registry-main'
import { LogManager } from '../logging/log-manager'
import { LogEvents } from '../logging/logging-events'
import { settings } from '../settings'
import { generateCSPHeader } from '../utils/csp'
import { Environment } from '../utils/environment'
import type {
  ProcessWindowOptions,
  RendererWindowOptions,
  WindowProcess,
} from './windows-manager-interface'

const logger = LogManager.getMainLogger('WindowsManager')

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const CLIENT_PRELOAD_PRELOAD_WEBPACK_ENTRY: string

/**
 * Manages the creation and lifecycle of windows in the Electron app.
 */
class WindowManagerClass {
  /**
   * List of all windows managed by the WindowManager.
   */
  private _windows: WindowProcess[] = []
  /**
   * Flag to track if any windows have been closed previously
   * to ensure IPC channels are reconnected correctly on reload.
   */
  private _hasClosedWindow = false

  /**
   * Creates a new background process hidden window. In development, the window will be visible with DevTools open.
   *
   * @param name                The name of the process
   * @param url                 The URL to load in the window
   * @param allowedDomains      The list of allowed domains the process can access externally
   * @param nodeIntegration     Whether to enable Node.js integration
   * @param directIPCChannel    Whether to enable direct IPC channel for all other windows to connect directly to this process
   * @returns                   The new {BrowserWindow}
   */
  public createProcessWindow({
    id,
    url,
    allowedDomains = [],
    nodeIntegration = false,
    directIPCChannel = false,
  }: ProcessWindowOptions): BrowserWindow {
    const processSession = session.fromPartition(`persist:${id}`)
    const processWindow = new BrowserWindow({
      width: 900,
      height: 600,
      show: Environment.nodeEnvironment === Environment.DEVELOPMENT,
      title: `Process: ${id}`,
      webPreferences: {
        session: processSession,
        nodeIntegration,
        webSecurity: !nodeIntegration,
        // TODO - For some reason preload doesn't work with contextIsolation and nodeIntegration enabled
        // Could be related to this bug: https://github.com/electron/forge/issues/2618
        contextIsolation: !nodeIntegration,
        sandbox: !nodeIntegration,
        additionalArguments: this._getAdditionalArgs(id),
        preload: CLIENT_PRELOAD_PRELOAD_WEBPACK_ENTRY,
      },
    })
    processWindow.loadURL(url)

    // Set up CSP header to allow external domain calls
    processSession.webRequest.onHeadersReceived((details, callback) => {
      callback({
        responseHeaders: {
          ...details.responseHeaders,
          'Content-Security-Policy': [
            generateCSPHeader(
              Environment.nodeEnvironment === Environment.DEVELOPMENT
                ? 'development'
                : 'production',
              { 'connect-src': allowedDomains },
            ),
          ],
        },
      })
    })

    // Initialise new process window
    this._initialiseWindow(id, processWindow, directIPCChannel)

    logger.info(`ðŸš€ ${id} process window created`)

    this._windows.push({ id, window: processWindow, type: 'process', directIPCChannel })
    return processWindow
  }

  /**
   * Create a new Renderer Window for displaying the app's UI to the user.
   *
   * @param id        The unique identifier of the window
   * @param url       The URL to load in the window
   * @param title     The title of the window
   * @param width     The width of the window
   * @param height    The height of the window
   * @param csp       (Optional) The Content Security Policy to apply to the window
   * @returns         The new {BrowserWindow}
   */
  public createRendererWindow({
    id,
    url,
    title,
    height,
    width,
    csp,
  }: RendererWindowOptions): BrowserWindow {
    // Create the browser window
    const rendererSession = session.fromPartition(`persist:${id}`)
    const rendererWindow = new BrowserWindow({
      title,
      height,
      width,
      webPreferences: {
        session: rendererSession,
        nodeIntegration: false,
        contextIsolation: true,
        sandbox: true,
        additionalArguments: this._getAdditionalArgs(id),
        preload: CLIENT_PRELOAD_PRELOAD_WEBPACK_ENTRY,
      },
    })

    // Set up CSP header to allow external domain calls if CSP is provided
    if (csp) {
      rendererSession.webRequest.onHeadersReceived((details, callback) => {
        callback({
          responseHeaders: {
            ...details.responseHeaders,
            'Content-Security-Policy': [
              generateCSPHeader(
                Environment.nodeEnvironment === Environment.DEVELOPMENT
                  ? 'development'
                  : 'production',
                csp,
              ),
            ],
          },
        })
      })
    }

    // Override file:// protocol for serving static assets in distribution
    if (!rendererSession.protocol.isProtocolHandled('file')) {
      logger.info(`Registering file protocol handler for renderer session persist:${id}`)
      rendererSession.protocol.handle('file', (request) => {
        const url = request.url.substring(7) /* all urls start with 'file://' */
        if (url.includes('/assets/')) {
          // Only rewrite files looking for assets folder
          const assetUrl = url.split('/assets/')[1]
          const newPath = path.normalize(`${__dirname}/../renderer/assets/${assetUrl}`)
          logger.silly(`Intercepted File protocol: url=${url}, newPath=${newPath}`)
          return net.fetch(`file://${newPath}`)
        }
        return net.fetch(`file://${url}`)
      })
    }

    rendererWindow.loadURL(url)

    // Initialise new process window
    this._initialiseWindow(id, rendererWindow)

    logger.info(`ðŸš€ ${id} renderer window created`)

    this._windows.push({ id, window: rendererWindow, type: 'renderer', directIPCChannel: false })
    return rendererWindow
  }

  /**
   * Ensure all window processes are started with the same additional arguments. These
   * arguments pass environment/app information to the process via the preload script
   * and window.environment object.
   *
   * @param id  The unique identifier of the window
   * @returns   The additional arguments to pass to the window
   */
  private _getAdditionalArgs(id: string): string[] {
    return [
      `--process=${id}`,
      `--environment=${Environment.nodeEnvironment}`,
      `--platform=${Environment.platform}`,
      `--logsDir=${Environment.logsDir}`,
    ]
  }

  /**
   * Initialise a new process/renderer to ensure all channels are connected correctly,
   * logging is set up and initialised, handle 'closed' events and any other initialisation
   * tasks are completed consistently across windows.
   *
   * @param id                  The unique identifier of the window
   * @param window              The window instance
   * @param directIPCChannel    Whether to enable direct IPC channel for all other windows
   *                            to connect directly to this process
   */
  private _initialiseWindow(id: string, window: BrowserWindow, directIPCChannel: boolean = false) {
    // Create logger for process
    LogManager.createProcessLogger(id)

    // Keep track of reload count
    let reloadCount = 0

    // Connect IPC channels on did-finish-load
    window.webContents.on('did-finish-load', () => {
      // Set logging level for process
      window.webContents.postMessage(LogEvents.ON_LOGGING_SET_LEVEL, settings.get('logLevel'))

      // Connect process to Main process via new IPC Channel
      const { port1, port2 } = new MessageChannelMain()
      window.webContents.postMessage(
        CommandRegistryEvents.REGISTER_NEW_CHANNEL,
        AppProcessIDs.MAIN,
        [port1],
      )
      CommandsRegistryMain.registerNewChannel(id, port2)

      // Connect process to all other processes via direct IPC Channel if directIPCChannel is enabled
      if (directIPCChannel) {
        this._windows
          .filter((win) => win.id !== id)
          .forEach((win) => {
            logger.info(`ðŸš€ ${id} connecting to ${win.id} via direct IPC channel`)
            const { port1: directPort1, port2: directPort2 } = new MessageChannelMain()
            window.webContents.postMessage(CommandRegistryEvents.REGISTER_NEW_CHANNEL, win.id, [
              directPort1,
            ])
            win.window.webContents.postMessage(CommandRegistryEvents.REGISTER_NEW_CHANNEL, id, [
              directPort2,
            ])
          })
      }

      // Re-Connect window to any processes that have direct IPC Channel enabled
      if (reloadCount > 0 || (this._hasClosedWindow && reloadCount === 0)) {
        // On initial load we don't want to re-connect direct IPC channels as the process
        // itself will connect to all other processes when it starts
        this._windows
          .filter((process) => process.directIPCChannel)
          .forEach((process) => {
            if (process.id !== id) {
              logger.info(`ðŸš€ ${id} re-connecting to ${process.id} via direct IPC channel`)
              const { port1: directPort1, port2: directPort2 } = new MessageChannelMain()
              window.webContents.postMessage(
                CommandRegistryEvents.REGISTER_NEW_CHANNEL,
                process.id,
                [directPort1],
              )
              process.window.webContents.postMessage(
                CommandRegistryEvents.REGISTER_NEW_CHANNEL,
                id,
                [directPort2],
              )
            }
          })
      }

      // Increment reload count
      reloadCount++

      // Open DevTools if developer environment
      if (Environment.nodeEnvironment === Environment.DEVELOPMENT) {
        // Open the DevTools.
        window.webContents.openDevTools()
      }
    })

    // Handle window close event
    window.on('closed', () => {
      logger.info(`ðŸ’¥ ${id} renderer window closed`)
      this._windows = this._windows.filter((w) => w.id !== id)
      this._hasClosedWindow = true
    })
  }

  /**
   * Check if a Window with the given ID exists.
   *
   * @param id  The unique identifier of the window
   * @returns   True if the window exists, false otherwise
   */
  public has(id: string): boolean {
    return this._windows.some((w) => w.id === id)
  }

  /**
   * Get a WindowProcess by ID.
   *
   * @param id  The unique identifier of the window
   * @returns   The WindowProcess if found, null otherwise
   */
  public get(id: string): BrowserWindow | null {
    const window = this._windows.find((w) => w.id === id)
    if (window) {
      return window.window
    }
    return null
  }
}

// Export instance of Class
export const WindowManager = new WindowManagerClass()
