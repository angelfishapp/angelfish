import { BrowserWindow, MessageChannelMain, session } from 'electron'
import path from 'path'

import { CommandRegistryEvents } from '@angelfish/core'
import { CommandsRegistryMain } from '../commands/commands-registry-main'
import { LogManager } from '../logging/log-manager'
import { LogEvents } from '../logging/logging-events'
import { MIN_WINDOW_HEIGHT, MIN_WINDOW_WIDTH, settings } from '../settings'
import { Environment } from '../utils/environment'
import { ProcessIDs } from './process-ids'

const logger = LogManager.getMainLogger('WindowsManager')

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const CLIENT_PRELOAD_PRELOAD_WEBPACK_ENTRY: string

/**
 * Holds information about a window process.
 */
interface WindowProcess {
  /**
   * The unique identifier of the process.
   */
  id: string
  /**
   * The window instance.
   */
  window: BrowserWindow
  /**
   * The type of the process.
   */
  type: 'renderer' | 'process'
  /**
   * Whether to enable direct IPC channel for all other windows to connect directly to this process
   * without using the main process as a mediator. Only use this for processes that have a lot of IPC
   * calls with other processes to reduce performance overhead on main process.
   */
  directIPCChannel: boolean
}

/**
 * Manages the creation and lifecycle of windows in the Electron app.
 */
class CWindowManager {
  private windows: WindowProcess[] = []

  /**
   * Creates a new background process hidden window. In development, the window will be visible with DevTools open.
   *
   * @param name                The name of the process
   * @param url                 The URL to load in the window
   * @param nodeIntegration     Whether to enable Node.js integration
   * @param directIPCChannel    Whether to enable direct IPC channel for all other windows to connect directly to this process
   * @returns                   The new {BrowserWindow}
   */
  public createProcessWindow(
    id: string,
    url: string,
    nodeIntegration: boolean = false,
    directIPCChannel: boolean = false,
  ): BrowserWindow {
    const processWindow = new BrowserWindow({
      width: 900,
      height: 600,
      show: Environment.nodeEnvironment === Environment.DEVELOPMENT,
      title: `Process: ${id}`,
      webPreferences: {
        session: session.fromPartition(`persist:${id}`),
        nodeIntegration,
        webSecurity: !nodeIntegration,
        // TODO - For some reason preload doesn't work with contextIsolation and nodeIntegration enabled
        // Could be related to this bug: https://github.com/electron/forge/issues/2618
        contextIsolation: !nodeIntegration,
        sandbox: !nodeIntegration,
        additionalArguments: [
          `--process=${id}`,
          `--environment=${Environment.nodeEnvironment}`,
          `--platform=${Environment.platform}`,
          `--logsDir=${Environment.logsDir}`,
        ],
        preload: CLIENT_PRELOAD_PRELOAD_WEBPACK_ENTRY,
      },
    })
    processWindow.loadURL(url)

    // Initialise new process window
    this._initialiseWindow(id, processWindow, directIPCChannel)

    logger.info(`ðŸš€ ${id} process window created`)

    this.windows.push({ id, window: processWindow, type: 'process', directIPCChannel })
    return processWindow
  }

  /**
   * Create a new Renderer Window for displaying the app's UI to the user.
   *
   * @param id        The unique identifier of the window
   * @param url       The URL to load in the window
   * @param width     The width of the window
   * @param height    The height of the window
   * @returns         The new {BrowserWindow}
   */
  public createRendererWindow(
    id: string,
    url: string,
    width: number,
    height: number,
  ): BrowserWindow {
    // Create the browser window.
    const rendererWindow = new BrowserWindow({
      height,
      width,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        sandbox: true,
        additionalArguments: [
          `--process=${id}`,
          `--environment=${Environment.nodeEnvironment}`,
          `--platform=${Environment.platform}`,
          `--logsDir=${Environment.logsDir}`,
        ],
        preload: CLIENT_PRELOAD_PRELOAD_WEBPACK_ENTRY,
      },
    })
    rendererWindow.loadURL(url)

    // Initialise new process window
    this._initialiseWindow(id, rendererWindow)

    logger.info(`ðŸš€ ${id} renderer window created`)

    this.windows.push({ id, window: rendererWindow, type: 'renderer', directIPCChannel: false })
    return rendererWindow
  }

  /**
   * Initialise a new process/renderer to ensure all channels are connected correctly,
   * logging is set up and initialised, handle 'closed' events and any other initialisation
   * tasks are completed consistently across windows.
   *
   * @param id                  The unique identifier of the window
   * @param window              The window instance
   * @param directIPCChannel    Whether to enable direct IPC channel for all other windows
   *                            to connect directly to this process
   */
  private _initialiseWindow(id: string, window: BrowserWindow, directIPCChannel: boolean = false) {
    // Create logger for process
    LogManager.createProcessLogger(id)

    // Keep track of reload count
    let reloadCount = 0

    // Connect IPC channels on did-finish-load
    window.webContents.on('did-finish-load', () => {
      // Set logging level for process
      window.webContents.postMessage(LogEvents.ON_LOGGING_SET_LEVEL, settings.get('logLevel'))

      // Connect process to Main process via new IPC Channel
      const { port1, port2 } = new MessageChannelMain()
      window.webContents.postMessage(CommandRegistryEvents.REGISTER_NEW_CHANNEL, ProcessIDs.MAIN, [
        port1,
      ])
      CommandsRegistryMain.registerNewChannel(id, port2)

      // Connect process to all other processes via direct IPC Channel if directIPCChannel is enabled
      if (directIPCChannel) {
        this.windows
          .filter((win) => win.id !== id)
          .forEach((win) => {
            logger.info(`ðŸš€ ${id} connecting to ${win.id} via direct IPC channel`)
            const { port1: directPort1, port2: directPort2 } = new MessageChannelMain()
            window.webContents.postMessage(CommandRegistryEvents.REGISTER_NEW_CHANNEL, win.id, [
              directPort1,
            ])
            win.window.webContents.postMessage(CommandRegistryEvents.REGISTER_NEW_CHANNEL, id, [
              directPort2,
            ])
          })
      }

      // Re-Connect window to any processes that have direct IPC Channel enabled
      if (reloadCount > 0) {
        // On initial load we don't want to re-connect direct IPC channels as the process
        // itself will connect to all other processes when it starts
        this.windows
          .filter((process) => process.directIPCChannel)
          .forEach((process) => {
            if (process.id !== id) {
              logger.info(`ðŸš€ ${id} re-connecting to ${process.id} via direct IPC channel`)
              const { port1: directPort1, port2: directPort2 } = new MessageChannelMain()
              window.webContents.postMessage(
                CommandRegistryEvents.REGISTER_NEW_CHANNEL,
                process.id,
                [directPort1],
              )
              process.window.webContents.postMessage(
                CommandRegistryEvents.REGISTER_NEW_CHANNEL,
                id,
                [directPort2],
              )
            }
          })
      }

      // Increment reload count
      reloadCount++

      // Open DevTools if developer environment
      if (Environment.nodeEnvironment === Environment.DEVELOPMENT) {
        // Open the DevTools.
        window.webContents.openDevTools()
      }
    })

    // Handle window close event
    window.on('closed', () => {
      logger.info(`ðŸ’¥ ${id} renderer window closed`)
      this.windows = this.windows.filter((w) => w.id !== id)
    })
  }

  /**
   * Create the main application window.
   *
   * @param url The URL to load in the window
   * @returns   The new {BrowserWindow}
   */
  public createMainAppWindow(url: string): BrowserWindow {
    const windowSize = settings.get('windowSize')
    const appWindow = this.createRendererWindow(
      ProcessIDs.APP,
      url,
      windowSize.width,
      windowSize.height,
    )
    appWindow.setTitle('Angelfish')
    appWindow.setMinimumSize(MIN_WINDOW_WIDTH, MIN_WINDOW_HEIGHT)
    appWindow.setIcon(path.join(__dirname, 'assets', '1024.png'))

    // Listen for resize events to remember user's last screen size
    appWindow.on('resize', function () {
      const size = appWindow.getSize()
      settings.set('windowSize', {
        width: size[0],
        height: size[1],
      })
    })

    return appWindow
  }

  /**
   * Check if a Window with the given ID exists.
   *
   * @param id  The unique identifier of the window
   * @returns   True if the window exists, false otherwise
   */
  public has(id: string): boolean {
    return this.windows.some((w) => w.id === id)
  }
}

/**
 * Main WindowManager for App.
 */
export const WindowManager = new CWindowManager()
