import type { Cell, SheetData } from 'write-excel-file'
import writeXlsxFile from 'write-excel-file/node'

import type { CategorySpendReportData } from '@angelfish/core'
import { renderPeriodHeader, ThemePallet } from './export-utils'

/**
 * Export the reports data to an Excel XLSX file with nice formatting
 */
export class ExportXLSX {
  // Define number cell formatting as Accounting style with -ve numbers in red
  // and zero values as "-"
  static readonly numberCellFormat = '_(* #,##0.00_);_(* [Red](#,##0.00);_(* "-"_);_(@_)'

  // Define the formatted header cell style
  static readonly formattedHeaderCell: Cell = {
    fontWeight: 'bold',
    color: '#FFFFFF',
    backgroundColor: ThemePallet.primary.main,
    alignVertical: 'center',
    topBorderStyle: 'thick',
    bottomBorderStyle: 'thick',
    height: 30,
  }

  // Define the formatted total cell style
  static readonly formattedTotalCell: Cell = {
    fontWeight: 'bold',
    backgroundColor: ThemePallet.summaryRowGrey,
    align: 'right',
    alignVertical: 'center',
    topBorderStyle: 'thick',
    bottomBorderStyle: 'thick',
  }

  // Define the formatted net cell style
  static readonly formattedNetCell: Cell = {
    fontWeight: 'bold',
    color: '#FFFFFF',
    backgroundColor: ThemePallet.primary.dark,
    align: 'right',
    alignVertical: 'center',
    topBorderStyle: 'thick',
    bottomBorderStyle: 'thick',
    height: 30,
  }

  /**
   * Export the reports data to a formatted XLSX file
   *
   * @param reportData  The reports data to export
   * @param filePath    The file path to save the XLSX file to
   */
  public static async Export(reportData: CategorySpendReportData, filePath: string): Promise<void> {
    // Create the sheet data
    const data: SheetData = []

    // Create Income section
    data.push(...this.renderTableSection(reportData, true, 0))
    const incomeSectionEndRow = data.length

    // Create Expenses section
    data.push(...this.renderTableSection(reportData, false, data.length))
    const expensesSectionEndRow = data.length

    // Create Net Row
    const netRow: Cell[] = [
      {
        value: 'NET',
        leftBorderStyle: 'thick',
        rightBorderStyle: 'thick',
        ...this.formattedNetCell,
      },
    ]
    for (const period of reportData.periods) {
      // Get current column letter from period
      const currentColumn = ExportXLSX.getExcelColumnLetter(reportData.periods.indexOf(period) + 2)
      if (period === 'total') {
        netRow.push({
          type: 'Formula',
          value: `${currentColumn}${incomeSectionEndRow} + ${currentColumn}${expensesSectionEndRow}`,
          leftBorderStyle: 'thick',
          rightBorderStyle: 'thick',
          format: this.numberCellFormat.replace('[Red]', ''),
          ...this.formattedNetCell,
        })
      } else {
        netRow.push({
          type: 'Formula',
          value: `${currentColumn}${incomeSectionEndRow} + ${currentColumn}${expensesSectionEndRow}`,
          format: this.numberCellFormat.replace('[Red]', ''),
          ...this.formattedNetCell,
        })
      }
    }
    data.push(netRow)

    // Add footer row
    data.push([
      {
        value: 'HYPERLINK("https://angelfish.app", "Generated by Angelfish")',
        type: 'Formula',
        align: 'left',
      },
      ...Array(reportData.periods.length).fill({}),
    ])

    // Write the file
    await writeXlsxFile(data, {
      columns: [{ width: 40 }, ...reportData.periods.map(() => ({ width: 13 }))],
      filePath,
      stickyColumnsCount: 1,
      fontFamily: 'Arial',
      fontSize: 16,
    })
  }

  /**
   * Render a table section for Income or Expenses, specified by isIncome flag
   *
   * @param reportData      The reports data to render
   * @param isIncome        Whether to render the Income or Expenses section
   * @param currentRow      The current row number section is starting from
   * @returns               The table section as Row<Cell>[]
   */
  private static renderTableSection(
    reportData: CategorySpendReportData,
    isIncome: boolean,
    currentRow: number,
  ): SheetData {
    const rows: SheetData = []

    // Create header row
    rows.push(ExportXLSX.renderHeaderRow(isIncome ? 'Income' : 'Expenses', reportData.periods))

    // Filter and sort report data by type
    const filteredRows = reportData.rows
      .filter((x) => x.type === (isIncome ? 'Income' : 'Expense'))
      .sort((a, b) => a.name.localeCompare(b.name))

    // Create rows for each category group, stripe the rows
    let isStriped = false
    for (const row of filteredRows) {
      // Create Category Group Row
      const dataRow: Cell[] = [
        {
          value: row.name,
          align: 'left',
          fontWeight: 'bold',
          leftBorderStyle: 'thick',
          rightBorderStyle: 'thick',
          backgroundColor: isStriped ? ThemePallet.stripedRowGrey : '#FFFFFF',
        },
        ...Array(reportData.periods.length - 1).fill({
          backgroundColor: isStriped ? ThemePallet.stripedRowGrey : '#FFFFFF',
        }),
        {
          backgroundColor: isStriped ? ThemePallet.stripedRowGrey : '#FFFFFF',
          leftBorderStyle: 'thick',
          rightBorderStyle: 'thick',
        },
      ]
      rows.push(dataRow)

      // Create Category Rows
      for (const category of (row.categories ? row.categories : []).sort((a, b) =>
        a.name.localeCompare(b.name),
      )) {
        const categoryRow: Cell[] = [
          {
            value: category.name,
            align: 'left',
            leftBorderStyle: 'thick',
            rightBorderStyle: 'thick',
            backgroundColor: isStriped ? ThemePallet.stripedRowGrey : '#FFFFFF',
            indent: 1,
          },
        ]
        for (const period of reportData.periods) {
          if (period === 'total') {
            categoryRow.push({
              type: 'Formula',
              value: `SUM(B${currentRow + rows.length + 1}:${ExportXLSX.getExcelColumnLetter(
                reportData.periods.length,
              )}${currentRow + rows.length + 1})`,
              align: 'right',
              fontWeight: 'bold',
              leftBorderStyle: 'thick',
              rightBorderStyle: 'thick',
              format: this.numberCellFormat,
              backgroundColor: isStriped ? ThemePallet.stripedRowGrey : '#FFFFFF',
            })
          } else {
            categoryRow.push({
              value: category[period] || 0,
              align: 'right',
              format: this.numberCellFormat,
              backgroundColor: isStriped ? ThemePallet.stripedRowGrey : '#FFFFFF',
            })
          }
        }
        rows.push(categoryRow)
      }

      // Toggle stripe
      isStriped = !isStriped
    }

    // Create Total Row
    const totalRow: Cell[] = [
      {
        value: `Total ${isIncome ? 'Income' : 'Expenses'}`,
        leftBorderStyle: 'thick',
        rightBorderStyle: 'thick',
        ...ExportXLSX.formattedTotalCell,
      },
    ]

    for (const period of reportData.periods) {
      // Get current column letter from period
      const currentColumn = ExportXLSX.getExcelColumnLetter(reportData.periods.indexOf(period) + 2)
      const rowNumber = currentRow + rows.length + 1
      if (period === 'total') {
        totalRow.push({
          type: 'Formula',
          value: `SUM(${currentColumn}${currentRow + 2}:${currentColumn}${rowNumber - 1})`,
          align: 'right',
          leftBorderStyle: 'thick',
          rightBorderStyle: 'thick',
          format: this.numberCellFormat,
          ...ExportXLSX.formattedTotalCell,
        })
      } else {
        totalRow.push({
          type: 'Formula',
          value: `SUM(${currentColumn}${currentRow + 2}:${currentColumn}${rowNumber - 1})`,
          format: this.numberCellFormat,
          align: 'right',
          ...ExportXLSX.formattedTotalCell,
        })
      }
    }
    rows.push(totalRow)

    return rows
  }

  /**
   * Render the header row for a table section
   *
   * @param title       The title of the section
   * @param periods     The periods to display in the header
   * @returns           The header row Cells[]
   */
  private static renderHeaderRow(title: string, periods: string[]): Cell[] {
    // Create Title Cell
    const headerRow: Cell[] = [
      {
        value: title,
        align: 'left',
        leftBorderStyle: 'thick',
        rightBorderStyle: 'thick',
        ...ExportXLSX.formattedHeaderCell,
      },
    ]
    for (const period of periods) {
      if (period === 'total') {
        headerRow.push({
          value: renderPeriodHeader(period),
          align: 'center',
          leftBorderStyle: 'thick',
          rightBorderStyle: 'thick',
          ...ExportXLSX.formattedHeaderCell,
        })
      } else {
        headerRow.push({
          value: renderPeriodHeader(period),
          align: 'center',
          ...ExportXLSX.formattedHeaderCell,
        })
      }
    }
    return headerRow
  }

  /**
   * Helper function to get the Excel column letter from the column index. Supports
   * columns above Z such as AA, AB, etc. or AAA, AAB, etc.
   *
   * @param index   Index of the column
   * @returns       The Excel column letter
   */
  private static getExcelColumnLetter(index: number): string {
    let columnLetter = ''

    while (index > 0) {
      const remainder = (index - 1) % 26
      columnLetter = String.fromCharCode(65 + remainder) + columnLetter
      index = Math.floor((index - 1) / 26)
    }

    return columnLetter
  }
}
